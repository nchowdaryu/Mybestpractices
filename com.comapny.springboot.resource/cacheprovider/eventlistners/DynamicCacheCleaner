import java.util.List;

import javax.annotation.PostConstruct;

import org.apache.commons.collections.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

import com.company.spring.caching.CacheConfiguration;
import com.company.spring.caching.EnhancedCacheManager;
import com.company.spring.caching.util.CachingProviderErrorCodes;

/**
 * This implementation is tied to creating a cache based on user session. When the user session expires, the cache needs to be removed as well. When
 * the cache gets removed, this implementation also removes the MBean registered.
 * 
 * @author uiak
 * 
 */
@Component
public class DynamicCacheCleaner {

	private static final Logger LOGGER = LoggerFactory.getLogger(DynamicCacheCleaner.class);

    @Autowired
    @Qualifier("cacheManager")
    private EnhancedCacheManager cacheManager;
    
    @PostConstruct
    public void afterPropertiesSet() {
        Assert.notNull(cacheManager,
                "This component requires cache manager bean as its dependency: provide a bean with cacheManager as its name..");
    }
    
    public void removeCaches(List<? extends CacheConfiguration> cacheConfigurations) {
        if (CollectionUtils.isEmpty(cacheConfigurations)) {
        	LOGGER.trace("No cache configurations implementing CacheConfiguration were found.");
            return;
        }
        
        LOGGER.trace("Found policies implementing CacheNameGenerationPolicy");

        for (CacheConfiguration config : cacheConfigurations) {
            if (config.isDynamic()) {
                try {
                    cacheManager.destroyData(config);
                } catch (Exception e) {
                    //There are valid cases when the Http Session based cache name generation policies
                    //would not be able to generate the cache name. For e.g. in the Internal Web Applications
                    //using DefaultClientScopedCacheNameGeneration Policy, we expect
                    //the "poid" to be available in the Http Session. What if the internal user
                    //never loads a client, i.e., log-on to the application and log-off,
                    //there will not be a POID in the Http Session. 
                    //So, we will handle the Runtime exception by logging a warning and continuing with 
                    //other cache cleanups in the list.
                	LOGGER.warn(MarkerFactory.getMarker(CachingProviderErrorCodes.CACHE_NAME_GENERATOR.getCode()), 
                			"{} threw a runtime exception. Skipping cache removal for the cache name generated by this policy. For more information, please see http://crewhub.vanguard.com/it/vpedia/Wiki%20Pages/Caching%20Provider%20FAQ.aspx#toclink5", config.getCacheEntryKeyGenerator().getClass().getName(), e);
                    continue;
                }
            }
        }
    }

    void setCacheManager(EnhancedCacheManager manager) {
        this.cacheManager = manager;
    }
}
