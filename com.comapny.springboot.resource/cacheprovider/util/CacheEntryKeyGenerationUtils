import static com.vanguard.spring.caching.Constants.DEFAULT_KEY;
import static com.vanguard.spring.caching.Constants.DEFAULT_PREFIX;

import java.text.MessageFormat;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.company.spring.caching.CacheEntryKeyGenerationPolicy;

/**
 * @author uiak
 * 
 */
public class CacheEntryKeyGenerationUtils {

	private static final Logger LOGGER = LoggerFactory.getLogger(CacheEntryKeyGenerationUtils.class);
    
    /**
     * Precedence is to use prefix, override if no override use key gen
     * algorithm.
     * 
     * @param cachingConfigurationName
     * @param cacheentrykeyprefix
     * @param overridecacheentrykey
     * @param pjp
     * @return String
     */
    public static String generateCacheKey(String cachingConfigurationName,
	    String cacheentrykeyprefix, String overridecacheentrykey,
	    ProceedingJoinPoint pjp, CacheEntryKeyGenerationPolicy keygenpolicyforprefix) {

    	// If key prefix is specified Only the target method parameters will be
    	// used to generate the dynamic part of the key.
    	if (cacheentrykeyprefix != null && !DEFAULT_PREFIX.equals(cacheentrykeyprefix)) {
    	    return generateKeyUsingKeyGenerator(keygenpolicyforprefix, cacheentrykeyprefix, pjp);
    	}
    
    	// Configuration provides neither override nor prefix keys. Use default
    	// key generation policy.
    	if ((overridecacheentrykey != null && DEFAULT_KEY.equals(overridecacheentrykey))
    		|| overridecacheentrykey == null) {
    	    return generateKeyUsingAllPointcutParameters(cachingConfigurationName, pjp);
    	}
        
    	LOGGER.trace("Interceptor configured for custom key for the cache {}", overridecacheentrykey);
    
    	// override key provided. Just use it as is to be the key.
    	return overridecacheentrykey;
    }

    /**
     * @param cacheentrykeyprefix
     * @param pjp
     * @return String
     */
    public static String generateKeyUsingKeyGenerator(
	    CacheEntryKeyGenerationPolicy keygenpolicy,
	    String cacheentrykeyprefix, ProceedingJoinPoint pjp) {
        
    	LOGGER.trace("Key prefix is defined - cache key will be generated using pointcutMethodArgumentsOnlyCacheEntryKeyGeneratorPolicy");    		
    	return keygenpolicy.generateCacheEntryKey(pjp, cacheentrykeyprefix);
    }

    /**
     * @param cachingConfigurationName
     * @param pjp
     * @return String
     */
    public static String generateKeyUsingAllPointcutParameters(String cachingConfigurationName, ProceedingJoinPoint pjp) {
        
    	LOGGER.trace("Interceptor configured with {} will return key generated by generator configured for {}", DEFAULT_KEY, cachingConfigurationName);
    	CacheEntryKeyGenerationPolicy cacheKeyGenerator = CacheConfigurationUtils.determineCachingConfiguration(cachingConfigurationName).getCacheEntryKeyGenerator();
        return cacheKeyGenerator.generateCacheEntryKey(pjp);
    }

    /**
     * @param keygroupid
     * @param generatedCacheKey
     * @return String
     */
    public static String applyKeyGroupId(String keygroupid, String generatedCacheKey) {
    	MessageFormat format = new MessageFormat("{0}^GROUPID={1}^");
    	String resultkey = format.format(new Object[] { generatedCacheKey, keygroupid });
    	return resultkey;
    }
}
